"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _extends = require("@babel/runtime/helpers/extends"), _objectWithoutProperties = require("@babel/runtime/helpers/objectWithoutProperties"), _defineProperty = require("@babel/runtime/helpers/defineProperty"), apolloCacheInvalidation = require("@jesstelford/apollo-cache-invalidation"), components = require("@apollo/client/react/components"), hoistStatics = require("hoist-non-react-statics"), mapValues = require("lodash.mapvalues"), React = require("react"), gql = require("graphql-tag"), reactAdopt = require("react-adopt"), memoizeOne = require("memoize-one");

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    default: e
  };
}

var _extends__default = _interopDefault(_extends), _objectWithoutProperties__default = _interopDefault(_objectWithoutProperties), _defineProperty__default = _interopDefault(_defineProperty), hoistStatics__default = _interopDefault(hoistStatics), mapValues__default = _interopDefault(mapValues), React__default = _interopDefault(React), gql__default = _interopDefault(gql), memoizeOne__default = _interopDefault(memoizeOne);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty__default.default(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const flatten = arr => Array.prototype.concat(...arr), SchemaContext = React__default.default.createContext({}), typeToRegex = type => new RegExp(`^${type}:`), queriesToPath = queries => queries.map(query => [ apolloCacheInvalidation.ROOT, new RegExp("^" + query) ]), relatedFieldsToPath = relatedFields => flatten(relatedFields.map(relatedField => (relatedField.fields || []).map(relatedPath => [ typeToRegex(relatedField.type), new RegExp("^" + relatedPath) ]))), generateInvalidateionPaths = memoizeOne__default.default(keystoneTypes => keystoneTypes.reduce((memo, {schema: {type: type, queries: queries = [], relatedFields: relatedFields = []}}) => (memo[type] = [ [ typeToRegex(type) ], ...queriesToPath(queries), ...relatedFieldsToPath(relatedFields) ], 
memo), {})), updater = (keystoneSchemaInfo, types) => {
  const cacheInvalidationFieldPaths = generateInvalidateionPaths(keystoneSchemaInfo), paths = flatten((Array.isArray(types) ? types : [ types ]).map(type => cacheInvalidationFieldPaths[type]));
  return apolloCacheInvalidation.invalidateFields(() => paths);
};

class KeystoneApolloQueryCacheBuster extends React__default.default.Component {
  constructor(...args) {
    super(...args), _defineProperty__default.default(this, "state", {
      data: null,
      dataSeen: !1,
      refetching: !1,
      loading: !1,
      networkStatus: 7
    });
  }
  static getDerivedStateFromProps(props, state) {
    const newState = {};
    let loading = props.loading, networkStatus = props.networkStatus, refetching = state.refetching;
    const cacheWasCleared = state.dataSeen && null !== props.data && (!props.data || !Object.keys(props.data).length);
    return !refetching || loading || cacheWasCleared || (refetching = !1, newState.refetching = refetching), 
    refetching && (loading = !0, networkStatus = 4), loading || (cacheWasCleared ? (refetching = !0, 
    newState.refetching = refetching, loading = !0, networkStatus = 4, props.refetch()) : (newState.dataSeen = !0, 
    newState.data = props.data)), newState.loading = loading, newState.networkStatus = networkStatus, 
    newState;
  }
  render() {
    const _this$props = this.props, {children: children} = _this$props;
    return children(_objectSpread(_objectSpread({}, _objectWithoutProperties__default.default(_this$props, [ "children" ])), {}, {
      data: this.state.data,
      loading: this.state.loading,
      networkStatus: this.state.networkStatus
    }));
  }
}

const KeystoneQuery = _ref => {
  let {children: children} = _ref, props = _objectWithoutProperties__default.default(_ref, [ "children" ]);
  return React__default.default.createElement(components.Query, props, renderProps => React__default.default.createElement(KeystoneApolloQueryCacheBuster, _extends__default.default({}, renderProps, {
    children: children
  })));
}, wrapUpdateFunc = (keystoneSchemaInfo, invalidateTypes, update) => (proxy, data) => (invalidateTypes && updater(keystoneSchemaInfo, invalidateTypes)(proxy, data), 
update(proxy, data));

class KeystoneMutation extends React__default.default.Component {
  render() {
    const _this$props2 = this.props, {invalidateTypes: invalidateTypes, children: children, update: updateProp = (() => {})} = _this$props2, props = _objectWithoutProperties__default.default(_this$props2, [ "invalidateTypes", "children", "update" ]);
    return React__default.default.createElement(SchemaContext.Consumer, null, keystoneSchemaInfo => {
      const interceptedUpdateProp = wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateProp);
      return React__default.default.createElement(components.Mutation, _extends__default.default({}, props, {
        update: interceptedUpdateProp
      }), (mutation, info) => {
        const mergedMutation = Object.entries(info || {}).reduce((memo, [key, value]) => (memo[key] || (memo[key] = value), 
        memo), _ref2 => {
          let interceptedUpdateOption, {update: updateOption = updateProp, optimisticResponse: optimisticResponse} = _ref2, rest = _objectWithoutProperties__default.default(_ref2, [ "update", "optimisticResponse" ]);
          if (optimisticResponse) {
            let optimisticHandled = !1;
            interceptedUpdateOption = (...args) => optimisticHandled ? wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateOption)(...args) : (optimisticHandled = !0, 
            updateOption(...args));
          } else interceptedUpdateOption = wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateOption);
          return mutation(_objectSpread({
            update: interceptedUpdateOption,
            optimisticResponse: optimisticResponse
          }, rest));
        });
        return children(mergedMutation, info);
      });
    });
  }
}

const META_QUERY = gql__default.default`
  query ListMeta {
    _ksListsMeta {
      schema {
        type
        queries
        relatedFields {
          type
          fields
        }
      }
    }
  }
`, emptyObject = Object.freeze(Object.create(null)), emptyArray = [];

let keystoneListsMeta = [];

class KeystoneProvider extends React__default.default.Component {
  render() {
    return React__default.default.createElement(KeystoneQuery, {
      query: META_QUERY
    }, ({data: data, loading: loading}) => (keystoneListsMeta = loading || !data ? emptyArray : data._ksListsMeta || emptyArray, 
    React__default.default.createElement(SchemaContext.Provider, {
      value: keystoneListsMeta
    }, this.props.children)));
  }
}

const withKeystone = Component => {
  const WrappingComponent = props => React__default.default.createElement(KeystoneProvider, null, React__default.default.createElement(Component, props));
  return WrappingComponent.displayName = `WithKeystone(${Component.displayName || Component.name})`, 
  hoistStatics__default.default(WrappingComponent, Component), WrappingComponent;
};

function injectIsOptimisticFlag(_ref3 = emptyObject) {
  let {resolvers: resolvers = emptyObject, defaults: defaults = emptyObject} = _ref3, rest = _objectWithoutProperties__default.default(_ref3, [ "resolvers", "defaults" ]);
  const injectIsOptimisticFlagToKeystoneTypes = memoizeOne__default.default((inputResolvers, keystoneTypes) => (keystoneTypes || []).reduce((memo, {schema: {type: type}}) => _objectSpread(_objectSpread({}, memo), {}, {
    [type]: _objectSpread(_objectSpread({}, memo[type]), {}, {
      _isOptimistic: (rootValue, args, {optimisticResponse: optimisticResponse}) => !!optimisticResponse
    })
  }), inputResolvers));
  return _objectSpread({
    resolvers: () => injectIsOptimisticFlagToKeystoneTypes(resolvers, keystoneListsMeta),
    defaults: _objectSpread(_objectSpread({}, defaults), {}, {
      _isOptimistic: !1
    })
  }, rest);
}

const flattenApollo = options => reactAdopt.adopt(mapValues__default.default(options, adoption => "function" == typeof adoption ? adoption : _ref4 => {
  let {render: render} = _ref4, props = _objectWithoutProperties__default.default(_ref4, [ "render" ]);
  return React__default.default.cloneElement(adoption, props, render);
}));

exports.KeystoneProvider = KeystoneProvider, exports.Mutation = KeystoneMutation, 
exports.Query = KeystoneQuery, exports.flattenApollo = flattenApollo, exports.injectIsOptimisticFlag = injectIsOptimisticFlag, 
exports.withKeystone = withKeystone;
